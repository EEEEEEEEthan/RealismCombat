# 对话框系统

## 概述
游戏采用基于对话框(Dialogue)的交互系统，所有游戏流程通过选择对话框选项来推进。这是一个简洁的菜单驱动架构，玩家通过做出选择来与游戏交互。

## 核心概念

### MenuDialogue - 菜单对话框
位于 `Scripts/Nodes/Dialogues/MenuDialogue.cs`

**核心功能：**
- 显示标题和选项列表
- 提供选项预览和描述
- 处理用户选择（键盘输入或MCP命令）
- 确认选项时播放音效
- 异步等待用户确认
- 与MCP系统集成，输出可选选项信息

**数据结构：**
- `DialogueData` - 对话框数据
  - `title` - 标题文本
  - `options` - 选项数组
- `DialogueOptionData` - 选项数据
  - `option` - 选项文本
  - `description` - 描述文本
  - `onPreview` - 预览时触发的回调
  - `onConfirm` - 确认时触发的回调
  - `available` - 是否可用

### ProgramRootNode - 程序根节点
位于 `Scripts/Nodes/ProgramRootNode.cs`

**职责：**
- 管理对话框生命周期
- 处理MCP命令请求
- 维护对话框栈（支持多层对话框）
- 控制对话框的激活状态

**对话框栈管理：**
- 使用 `dialogues` 容器存储所有对话框
- 栈顶对话框为当前激活的对话框
- 创建新对话框时自动将旧对话框设为非激活状态
- 支持通过 `CreateDialogue()` 创建新对话框

## 交互流程

### 1. 键盘交互
- **上下方向键**：在选项间移动选择
- **确认键**：确认当前选择的选项
- 光标箭头跟随当前选择，并在有输入时改变颜色

### 2. MCP交互
- 对话框激活时自动输出选项列表到MCP
- 使用 `game_select_option <index>` 命令选择选项
- 选项确认后自动调用 `McpRespond()` 返回结果

## 生命周期

### 对话框创建
1. 调用 `MenuDialogue.Create(programRoot)` 创建实例
2. 使用 `Initialize(DialogueData)` 初始化数据
3. 添加到 `dialogues` 容器
4. 设置为激活状态（自动输出MCP信息）

### 对话框销毁
1. 选项的 `onConfirm` 回调中调用 `QueueFree()`
2. 退出场景树时自动调用 `Complete()`
3. 完成 `TaskCompletionSource`，允许异步等待

### 对话框激活控制
- `Active` 属性控制对话框是否响应输入
- 激活时输出MCP选项信息
- 标题显示与激活状态绑定
- 栈顶对话框始终为激活状态

## 典型用例

### 主菜单
```csharp
var dialogue = MenuDialogue.Create(programRoot);
dialogues.AddChild(dialogue);
dialogue.Initialize(new()
{
    title = "主菜单",
    options =
    [
        new()
        {
            option = "开始游戏",
            description = "开始新游戏",
            onConfirm = () =>
            {
                dialogue.QueueFree();
                // 创建游戏场景
            },
            available = true,
        },
        new()
        {
            option = "退出",
            description = "退出游戏",
            onConfirm = () =>
            {
                GetTree().Quit();
            },
            available = true,
        },
    ],
});
```

### 多层对话框
- 使用 `CreateDialogue()` 创建新对话框时，旧对话框自动变为非激活状态
- 新对话框销毁后，需要手动重新激活之前的对话框（如需要）
- `_Process` 中自动确保栈顶对话框始终激活

## MCP命令处理

### OnMcpRequest(string command)
位于 `ProgramRootNode.cs`，处理所有MCP命令：

**支持的命令：**
- `system_launch_program` - 刷新当前对话框，重新发送MCP信息
- `game_select_option <index>` - 选择并确认指定索引的选项
- `show_node_tree` - 显示节点树结构
- `game_quit` - 退出游戏

**命令格式：**
使用正则表达式匹配命令模式，例如：
```csharp
if (new Regex(@"game_select_option (\d+)").TryMatch(command, out var match))
{
    var optionId = int.Parse(match.Groups[1].ToString());
    currentDialogue.Confirm(optionId);
}
```

## 设计优势

1. **简洁性**：相比状态机系统，对话框系统更加直观和易于理解
2. **灵活性**：可以动态创建和销毁对话框，轻松构建多层菜单
3. **可测试性**：与MCP系统深度集成，支持自动化测试
4. **异步友好**：使用 `TaskCompletionSource` 支持异步等待用户选择
5. **清晰的生命周期**：对话框的创建、激活、销毁流程明确

## 实现文件

- `Scripts/Nodes/Dialogues/MenuDialogue.cs` - 菜单对话框实现
- `Scripts/Nodes/Dialogues/GenericDialogue.cs` - 通用对话框基类
- `Scripts/Nodes/ProgramRootNode.cs` - 程序根节点，对话框管理器
- `Scripts/Nodes/Components/PrinterLabelNode.cs` - 打字机效果标签组件
- `Scenes/Dialogues/MenuDialogue.tscn` - 对话框场景资源

